Задача:

Нужно реализовать operation-based conflict-free replicated data type как map ключ -> значение, last writer wins. (Last-Write-Wins-Element-Set).  Обеспечить reliable broadcast with causal order, нельзя просто брать физические timestamps с разных реплик для определения, кто более свежий. Например, если на реплике А добавили значение, она синхронизовала это с репликой B, потом на реплике B значение удалили, то по локальному физическому времени реплики A добавление значения может быть "позже" удаления на реплике B по её локальному времени, хотя событие создания было причиной события удаления — не попадитесь в эту ловушку!

Каждая реплика будет отдельным HTTP сервером, который позволит менять поля в множестве через запрос PATCH, в котором будет передаваться изменяемое подмножество полей как JSON. Реплики должны при наличии соединения между собой синхронизовывать состояние, при отсутствии соединения — работать автономно.

Система должна обладать свойством strong eventual consistency.

```
go run client.go -addr http://localhost:8081 -dump
go run client.go -addr http://localhost:8081 -vclock
go run client.go -addr http://localhost:8081 -patch '1=11,2=22'
```

```
go run server.go -port 8081 -peers 8082
go run server.go -port 8082 -peers 8081
```
